基于Huffman算法的压缩器
=======================

问题描述：
----------

【基本要求】

>   设计一个哈夫曼编码、译码系统。对一个文本文件中的字符进行哈夫曼编码，生成编码文件；反过来，可将编码文件译码还原为一个文本文件。

>   (1) 读入一篇英文短文(文件扩展名为txt)；

>   (2) 统计并输出不同字符在文章中出现的频率(空格、换行、标点等也按字符处理)；

>   (3）根据字符频率构建哈夫曼树，并给出每个字符的哈夫曼编码；

>   (4）哈夫曼编码；

>   (5）利用已建好的哈夫曼树，将文本文件进行编码，生成压缩文件(编码文件后缀名为.huf)；

>   (6）用哈夫曼编码存储的文件和输入文本文件大小进行比较，计算文件压缩率；

>   (7）进行译码，将huf文件译码为txt文件，与原txt文件进行比较。

【测试数据】

>   文本文件自行选择，至少含3000个字符。

基本思路
--------

将文件读到内存中，统计出出现的字符的频度，据此建立哈夫曼树并进行哈夫曼编码。然后再次将文件读到内存中，根据已经获得的哈夫曼编码得到压缩过的内容（暗文）。将这个暗文和解压时候需要的一些信息（称为头部信息）输出到.huf文件。解压的时候根据头部信息重新再内存中重新生成哈夫曼树，显然这和原来的哈夫曼树是一样的。根据这个哈夫曼树，将暗文翻译出来，输出到.txt文件。

实现细节
--------

### 读取原文

将英文文本读入内存的时候，面临着对两种数据结构的选择：链表和数组。使用链表的话，发现一个新种类的字符就多申请一个node的空间。但是链表不能随机访问，可能导致后续操作不方便，所以一开始选择了数组存储。

数组存储的常见优点是可以随机访问，常见的缺点是浪费空间。但是在这个项目里，我发现ASCII码一共只有128个字符，这并不是一个巨大的开销。而且，数组的下标是连续的，这个性质和ASCII码是一致的，利用这个对应关系可以简化很多问题。比如，获得一个字符之后，把它的十进制ASCII码作为下标就可以访问到其他成员（频率、编码）。又比如，

然后的问题是构造一个什么数组，我定义了如下的结构体：

typedef struct WORD

{

char\* word; //这个字符叫什么，可显字符很简单，不可显的就存它的名字。

int frequency; //出现的次数

char \*huffmanCode; //它的Huffman编码

}\*pWORD;

值得一提的是，对于大部分可显字符，它的提法就是显示出来的东西。但是有一小部分可显字符（标点符号）以及不可显字符则需要在初始化的时候手动输入我们平时称呼它们的名字。

### 生成哈夫曼树及编码

获得了所有字符的出现频率（即权重）之后，就可以据此在内存中生成哈夫曼树了。这里照搬了哈夫曼算法。

### 输出二进制文件

获得二进制编码之后，下一步就是把文章转成哈夫曼编码，存到磁盘中。

第一个想法是再一次以char为单位遍历一遍原文，然后利用读来的ASCII码访问words[
]，得到它的编码，然后存到另一个.txt文件里面。但是细想就知道这是错误的，这样子得到的文件会数倍于原文件。因为每一个字符都变成了几个字符。

所以，很显然要以bit为单位记录0和1，而不是大小为一个字节的ASCII码对应的0和1。可是C语言没有这么小的数据类型，所以要通过位运算来实现。方法就是：获得了哈夫曼编码之后，一位一位地判断是0还是1。然后通过左移一位(0)和与1(1)进行
\| 运算来实现对bit的编码。

接下来，要把这一串bit存入磁盘文件。哈夫曼的编码是不等长的，这和fwrite(
)只能以字符（8bit）为最小单位进行存储形成了矛盾。解决方法是，设置一个暂存空间char_temp，存满8bit就向磁盘输出一次。

这里还有一个细节问题，就是原文译成哈夫曼编码之后的bit量并不一定是8的整倍数，所以最后只能用0来填补以凑满8bit。但是，仔细想一下就发现并没有问题。首先，只是多存了几个bit，这和文件总大小相比可以忽略不计。其次，由于哈夫曼编码是前缀码，所以在最后补任何东西都不会造成歧义。

在向磁盘写文件的时候，要注意“头部文件”的顺序。比如各种字符的频率及其ASCII码一定要写在正文的前面，而一共有多少种字符又要在具体字符情况的前面，不然解码的时候就不知道读多少位下去。还要注意各种数据类型一定要和解码时候读的步长相同。

### 解码

解码有很多种方案。这个也可以放在输出的那一节讨论，因为如何解码反过来会要求输出的时候存那些东西。说白了，就是如何简洁高效地协定的问题。

这里我选择了通过读取各种字符的频率及其ASCII码并在内存中重新构建哈夫曼树的方式。

否定的方案及其理由：

1.  储存哈夫曼编码表

    1.  细节：把字符及其对应的编码储存在开头。然后绕过树直接获得编码。

    2.  否定的理由：

        1.  哈夫曼编码是不等长的，而且在读文件的时候是没有哈夫曼树的，所以无法确定应该读几位。

        2.  如果妥协一下，用char而非bit来储存编码，则可以通过加哨点的方法（-1）来确定读几位。但是这样子会增加一定的文件大小。

        3.  最终要的是，就算有一种我没有想到的方法解决了储存编码的问题，直接使用编码本身来解密文件本省就用硬伤。我们默认既然存了编码，就一定是不想再生成树了（虽然也可以，但是就要重写哈夫曼树的生成函数了，因为这是完全不同的方法，增加了代码量），因为那就几乎回到了我最后选择了的方法。那么拿这个对照表来解密，要读懂每一个编码，都要重复若干次数的遍历表的过程。这个次数取决于编码的长度，因为非等长的要求使得我们要以每次增加一位的方式来试探究竟到多少位编码就变的有意义了。这使得时间复杂度变得很大。所以如果没有一种高效使用编码表的方式，从压缩文件复现编码表的方法再巧妙也没有用。

2.  储存哈夫曼树

    1.  细节：把哈夫曼树储存在开头。

    2.  否定的理由：

        1.  没有想到比较合适的储存方法。通过先序加中序的方法也许可以，但是这样子代码量就更大了，没有必要。

收获
----

### 复现能力很重要

哈夫曼这个程序的难度大概就是处理好内存，尤其是各种类型的数据以及处理输入输出。当出现错误、或者想检验某几行代码的时候，如果程序过于复杂，应该在一个尽量简单的环境下复现这个过程，便于排除其余代码的干扰。

### 规划要分步

在一开始，因为对程序缺乏把握，所以只能规划最简单的模块。然后依然应该遵循逐渐细化的原则，而不是埋头瞎写。在这个程序的编写过程中，出现了以下因为缺乏规划意识而导致的问题：

1.  函数分块不够细，耦合度太高，导致想使用其中部分功能的时候要重写一遍。

2.  变量的声明周期没考虑好，导致后期接口乱七八糟乱传一通。

3.  结构体设计不合理，导致后期要搞一些辅助变量来配合。

4.  重复功能的代码太多，这是第一点导致的。

### 变量名命名也很重要

一个好的变量名并不会对程序有什么好处，但是在编写的时候，它可以让代码变得清晰。而混乱的命名规则、模糊不清的用词，会使得自己阅读自己的代码都成为负担。

改进方向
--------

### 时而出现的bug

不知道为什么，调试程序的时候，即使什么都不改动，每一次的结果也不一定一样。一个关于strcat.asm的bug，有时候就会出现

### 归并代码

由于规划不合理，缺乏前瞻性，代码里面出现了一定的重复代码。有一些重构的函数只是因为约定没有一致而写，其内容几乎一致。有的函数太长，应该拆分成几个小的函数。

### 界面

可以用Qt或者VB制作一个简单的页面。
